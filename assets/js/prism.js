/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism-coy&languages=markup+clike+c+csharp+bash+batch+cpp+aspnet+arduino+docker+markup-templating+git+json+markdown+nginx+perl+php+php-extras+sql+powershell+python+textile&plugins=line-highlight+jsonp-highlight+highlight-keywords+previewers+command-line+normalize-whitespace */
var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function () { var e = /\blang(?:uage)?-([\w-]+)\b/i, t = 0, n = _self.Prism = { manual: _self.Prism && _self.Prism.manual, disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler, util: { encode: function (e) { return e instanceof a ? new a(e.type, n.util.encode(e.content), e.alias) : "Array" === n.util.type(e) ? e.map(n.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (e) { return Object.prototype.toString.call(e).slice(8, -1) }, objId: function (e) { return e.__id || Object.defineProperty(e, "__id", { value: ++t }), e.__id }, clone: function (e, t) { var a = n.util.type(e); switch (t = t || {}, a) { case "Object": if (t[n.util.objId(e)]) return t[n.util.objId(e)]; var r = {}; t[n.util.objId(e)] = r; for (var l in e) e.hasOwnProperty(l) && (r[l] = n.util.clone(e[l], t)); return r; case "Array": if (t[n.util.objId(e)]) return t[n.util.objId(e)]; var r = []; return t[n.util.objId(e)] = r, e.forEach(function (e, a) { r[a] = n.util.clone(e, t) }), r }return e } }, languages: { extend: function (e, t) { var a = n.util.clone(n.languages[e]); for (var r in t) a[r] = t[r]; return a }, insertBefore: function (e, t, a, r) { r = r || n.languages; var l = r[e], i = {}; for (var o in l) if (l.hasOwnProperty(o)) { if (o == t) for (var s in a) a.hasOwnProperty(s) && (i[s] = a[s]); a.hasOwnProperty(o) || (i[o] = l[o]) } var u = r[e]; return r[e] = i, n.languages.DFS(n.languages, function (t, n) { n === u && t != e && (this[t] = i) }), i }, DFS: function (e, t, a, r) { r = r || {}; for (var l in e) e.hasOwnProperty(l) && (t.call(e, l, e[l], a || l), "Object" !== n.util.type(e[l]) || r[n.util.objId(e[l])] ? "Array" !== n.util.type(e[l]) || r[n.util.objId(e[l])] || (r[n.util.objId(e[l])] = !0, n.languages.DFS(e[l], t, l, r)) : (r[n.util.objId(e[l])] = !0, n.languages.DFS(e[l], t, null, r))) } }, plugins: {}, highlightAll: function (e, t) { n.highlightAllUnder(document, e, t) }, highlightAllUnder: function (e, t, a) { var r = { callback: a, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; n.hooks.run("before-highlightall", r); for (var l, i = r.elements || e.querySelectorAll(r.selector), o = 0; l = i[o++];)n.highlightElement(l, t === !0, r.callback) }, highlightElement: function (t, a, r) { for (var l, i, o = t; o && !e.test(o.className);)o = o.parentNode; o && (l = (o.className.match(e) || [, ""])[1].toLowerCase(), i = n.languages[l]), t.className = t.className.replace(e, "").replace(/\s+/g, " ") + " language-" + l, t.parentNode && (o = t.parentNode, /pre/i.test(o.nodeName) && (o.className = o.className.replace(e, "").replace(/\s+/g, " ") + " language-" + l)); var s = t.textContent, u = { element: t, language: l, grammar: i, code: s }; if (n.hooks.run("before-sanity-check", u), !u.code || !u.grammar) return u.code && (n.hooks.run("before-highlight", u), u.element.textContent = u.code, n.hooks.run("after-highlight", u)), n.hooks.run("complete", u), void 0; if (n.hooks.run("before-highlight", u), a && _self.Worker) { var g = new Worker(n.filename); g.onmessage = function (e) { u.highlightedCode = e.data, n.hooks.run("before-insert", u), u.element.innerHTML = u.highlightedCode, n.hooks.run("after-highlight", u), n.hooks.run("complete", u), r && r.call(u.element) }, g.postMessage(JSON.stringify({ language: u.language, code: u.code, immediateClose: !0 })) } else u.highlightedCode = n.highlight(u.code, u.grammar, u.language), n.hooks.run("before-insert", u), u.element.innerHTML = u.highlightedCode, n.hooks.run("after-highlight", u), n.hooks.run("complete", u), r && r.call(t) }, highlight: function (e, t, r) { var l = { code: e, grammar: t, language: r }; return n.hooks.run("before-tokenize", l), l.tokens = n.tokenize(l.code, l.grammar), n.hooks.run("after-tokenize", l), a.stringify(n.util.encode(l.tokens), l.language) }, matchGrammar: function (e, t, a, r, l, i, o) { var s = n.Token; for (var u in a) if (a.hasOwnProperty(u) && a[u]) { if (u == o) return; var g = a[u]; g = "Array" === n.util.type(g) ? g : [g]; for (var c = 0; c < g.length; ++c) { var h = g[c], f = h.inside, d = !!h.lookbehind, m = !!h.greedy, p = 0, y = h.alias; if (m && !h.pattern.global) { var v = h.pattern.toString().match(/[imuy]*$/)[0]; h.pattern = RegExp(h.pattern.source, v + "g") } h = h.pattern || h; for (var b = r, k = l; b < t.length; k += t[b].length, ++b) { var w = t[b]; if (t.length > e.length) return; if (!(w instanceof s)) { if (m && b != t.length - 1) { h.lastIndex = k; var _ = h.exec(e); if (!_) break; for (var j = _.index + (d ? _[1].length : 0), P = _.index + _[0].length, A = b, x = k, O = t.length; O > A && (P > x || !t[A].type && !t[A - 1].greedy); ++A)x += t[A].length, j >= x && (++b, k = x); if (t[b] instanceof s) continue; I = A - b, w = e.slice(k, x), _.index -= k } else { h.lastIndex = 0; var _ = h.exec(w), I = 1 } if (_) { d && (p = _[1] ? _[1].length : 0); var j = _.index + p, _ = _[0].slice(p), P = j + _.length, N = w.slice(0, j), S = w.slice(P), C = [b, I]; N && (++b, k += N.length, C.push(N)); var E = new s(u, f ? n.tokenize(_, f) : _, y, _, m); if (C.push(E), S && C.push(S), Array.prototype.splice.apply(t, C), 1 != I && n.matchGrammar(e, t, a, b, k, !0, u), i) break } else if (i) break } } } } }, tokenize: function (e, t) { var a = [e], r = t.rest; if (r) { for (var l in r) t[l] = r[l]; delete t.rest } return n.matchGrammar(e, a, t, 0, 0, !1), a }, hooks: { all: {}, add: function (e, t) { var a = n.hooks.all; a[e] = a[e] || [], a[e].push(t) }, run: function (e, t) { var a = n.hooks.all[e]; if (a && a.length) for (var r, l = 0; r = a[l++];)r(t) } } }, a = n.Token = function (e, t, n, a, r) { this.type = e, this.content = t, this.alias = n, this.length = 0 | (a || "").length, this.greedy = !!r }; if (a.stringify = function (e, t, r) { if ("string" == typeof e) return e; if ("Array" === n.util.type(e)) return e.map(function (n) { return a.stringify(n, t, e) }).join(""); var l = { type: e.type, content: a.stringify(e.content, t, r), tag: "span", classes: ["token", e.type], attributes: {}, language: t, parent: r }; if (e.alias) { var i = "Array" === n.util.type(e.alias) ? e.alias : [e.alias]; Array.prototype.push.apply(l.classes, i) } n.hooks.run("wrap", l); var o = Object.keys(l.attributes).map(function (e) { return e + '="' + (l.attributes[e] || "").replace(/"/g, "&quot;") + '"' }).join(" "); return "<" + l.tag + ' class="' + l.classes.join(" ") + '"' + (o ? " " + o : "") + ">" + l.content + "</" + l.tag + ">" }, !_self.document) return _self.addEventListener ? (n.disableWorkerMessageHandler || _self.addEventListener("message", function (e) { var t = JSON.parse(e.data), a = t.language, r = t.code, l = t.immediateClose; _self.postMessage(n.highlight(r, n.languages[a], a)), l && _self.close() }, !1), _self.Prism) : _self.Prism; var r = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop(); return r && (n.filename = r.src, n.manual || r.hasAttribute("data-manual") || ("loading" !== document.readyState ? window.requestAnimationFrame ? window.requestAnimationFrame(n.highlightAll) : window.setTimeout(n.highlightAll, 16) : document.addEventListener("DOMContentLoaded", n.highlightAll))), _self.Prism }(); "undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism);
Prism.languages.markup = { comment: /<!--[\s\S]*?-->/, prolog: /<\?[\s\S]+?\?>/, doctype: /<!DOCTYPE[\s\S]+?>/i, cdata: /<!\[CDATA\[[\s\S]*?]]>/i, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/i, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "attr-value": { pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i, inside: { punctuation: [/^=/, { pattern: /(^|[^\\])["']/, lookbehind: !0 }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: /&#?[\da-z]{1,8};/i }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.hooks.add("wrap", function (a) { "entity" === a.type && (a.attributes.title = a.content.replace(/&amp;/, "&")) }), Prism.languages.xml = Prism.languages.markup, Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup;
Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, "boolean": /\b(?:true|false)\b/, "function": /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
Prism.languages.c = Prism.languages.extend("clike", { keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?/, number: /(?:\b0x[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im, lookbehind: !0, alias: "property", inside: { string: { pattern: /(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/, lookbehind: !0 }, directive: { pattern: /(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/, lookbehind: !0, alias: "keyword" } } }, constant: /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/ }), delete Prism.languages.c["class-name"], delete Prism.languages.c["boolean"];
Prism.languages.csharp = Prism.languages.extend("clike", { keyword: /\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/, string: [{ pattern: /@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/, greedy: !0 }, { pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/, greedy: !0 }], "class-name": [{ pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=\s+\w+)/, inside: { punctuation: /\./ } }, { pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/, lookbehind: !0, inside: { punctuation: /\./ } }, { pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/, lookbehind: !0, inside: { punctuation: /\./ } }, { pattern: /((?:\b(?:class|interface|new)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/, lookbehind: !0, inside: { punctuation: /\./ } }], number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)f?/i, operator: />>=?|<<=?|[-=]>|([-+&|?])\1|~|[-+*\/%&|^!=<>]=?/, punctuation: /\?\.?|::|[{}[\];(),.:]/ }), Prism.languages.insertBefore("csharp", "class-name", { "generic-method": { pattern: /\w+\s*<[^>\r\n]+?>\s*(?=\()/, inside: { "function": /^\w+/, "class-name": { pattern: /\b[A-Z]\w*(?:\.\w+)*\b/, inside: { punctuation: /\./ } }, keyword: Prism.languages.csharp.keyword, punctuation: /[<>(),.:]/ } }, preprocessor: { pattern: /(^\s*)#.*/m, lookbehind: !0, alias: "property", inside: { directive: { pattern: /(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/, lookbehind: !0, alias: "keyword" } } } }), Prism.languages.dotnet = Prism.languages.csharp;
!function (e) { var t = { variable: [{ pattern: /\$?\(\([\s\S]+?\)\)/, inside: { variable: [{ pattern: /(^\$\(\([\s\S]+)\)\)/, lookbehind: !0 }, /^\$\(\(/], number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/, operator: /--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/, punctuation: /\(\(?|\)\)?|,|;/ } }, { pattern: /\$\([^)]+\)|`[^`]+`/, greedy: !0, inside: { variable: /^\$\(|^`|\)$|`$/ } }, /\$(?:[\w#?*!@]+|\{[^}]+\})/i] }; e.languages.bash = { shebang: { pattern: /^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/, alias: "important" }, comment: { pattern: /(^|[^"{\\])#.*/, lookbehind: !0 }, string: [{ pattern: /((?:^|[^<])<<\s*)["']?(\w+?)["']?\s*\r?\n(?:[\s\S])*?\r?\n\2/, lookbehind: !0, greedy: !0, inside: t }, { pattern: /(["'])(?:\\[\s\S]|\$\([^)]+\)|`[^`]+`|(?!\1)[^\\])*\1/, greedy: !0, inside: t }], variable: t.variable, "function": { pattern: /(^|[\s;|&])(?:alias|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|hash|head|help|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logout|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tail|tar|tee|test|time|timeout|times|top|touch|tr|traceroute|trap|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip|zypper)(?=$|[\s;|&])/, lookbehind: !0 }, keyword: { pattern: /(^|[\s;|&])(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|[\s;|&])/, lookbehind: !0 }, "boolean": { pattern: /(^|[\s;|&])(?:true|false)(?=$|[\s;|&])/, lookbehind: !0 }, operator: /&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/, punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];]/ }; var a = t.variable[1].inside; a.string = e.languages.bash.string, a["function"] = e.languages.bash["function"], a.keyword = e.languages.bash.keyword, a["boolean"] = e.languages.bash["boolean"], a.operator = e.languages.bash.operator, a.punctuation = e.languages.bash.punctuation, e.languages.shell = e.languages.bash }(Prism);
!function (e) { var r = /%%?[~:\w]+%?|!\S+!/, t = { pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im, alias: "attr-name", inside: { punctuation: /:/ } }, n = /"[^"]*"/, i = /(?:\b|-)\d+\b/; e.languages.batch = { comment: [/^::.*/m, { pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im, lookbehind: !0 }], label: { pattern: /^:.*/m, alias: "property" }, command: [{ pattern: /((?:^|[&(])[ \t]*)for(?: ?\/[a-z?](?:[ :](?:"[^"]*"|\S+))?)* \S+ in \([^)]+\) do/im, lookbehind: !0, inside: { keyword: /^for\b|\b(?:in|do)\b/i, string: n, parameter: t, variable: r, number: i, punctuation: /[()',]/ } }, { pattern: /((?:^|[&(])[ \t]*)if(?: ?\/[a-z?](?:[ :](?:"[^"]*"|\S+))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|\S+)?(?:==| (?:equ|neq|lss|leq|gtr|geq) )(?:"[^"]*"|\S+))/im, lookbehind: !0, inside: { keyword: /^if\b|\b(?:not|cmdextversion|defined|errorlevel|exist)\b/i, string: n, parameter: t, variable: r, number: i, operator: /\^|==|\b(?:equ|neq|lss|leq|gtr|geq)\b/i } }, { pattern: /((?:^|[&()])[ \t]*)else\b/im, lookbehind: !0, inside: { keyword: /^else\b/i } }, { pattern: /((?:^|[&(])[ \t]*)set(?: ?\/[a-z](?:[ :](?:"[^"]*"|\S+))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im, lookbehind: !0, inside: { keyword: /^set\b/i, string: n, parameter: t, variable: [r, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/], number: i, operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/, punctuation: /[()',]/ } }, { pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im, lookbehind: !0, inside: { keyword: /^\w+\b/i, string: n, parameter: t, label: { pattern: /(^\s*):\S+/m, lookbehind: !0, alias: "property" }, variable: r, number: i, operator: /\^/ } }], operator: /[&@]/, punctuation: /[()']/ } }(Prism);
Prism.languages.cpp = Prism.languages.extend("c", { keyword: /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, "boolean": /\b(?:true|false)\b/, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/ }), Prism.languages.insertBefore("cpp", "keyword", { "class-name": { pattern: /(class\s+)\w+/i, lookbehind: !0 } }), Prism.languages.insertBefore("cpp", "string", { "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: !0 } });
Prism.languages.aspnet = Prism.languages.extend("markup", { "page-directive tag": { pattern: /<%\s*@.*%>/i, inside: { "page-directive tag": /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i, rest: Prism.languages.markup.tag.inside } }, "directive tag": { pattern: /<%.*%>/i, inside: { "directive tag": /<%\s*?[$=%#:]{0,2}|%>/i, rest: Prism.languages.csharp } } }), Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i, Prism.languages.insertBefore("inside", "punctuation", { "directive tag": Prism.languages.aspnet["directive tag"] }, Prism.languages.aspnet.tag.inside["attr-value"]), Prism.languages.insertBefore("aspnet", "comment", { "asp comment": /<%--[\s\S]*?--%>/ }), Prism.languages.insertBefore("aspnet", Prism.languages.javascript ? "script" : "tag", { "asp script": { pattern: /(<script(?=.*runat=['"]?server['"]?)[\s\S]*?>)[\s\S]*?(?=<\/script>)/i, lookbehind: !0, inside: Prism.languages.csharp || {} } });
Prism.languages.arduino = Prism.languages.extend("cpp", { keyword: /\b(?:setup|if|else|while|do|for|return|in|instanceof|default|function|loop|goto|switch|case|new|try|throw|catch|finally|null|break|continue|boolean|bool|void|byte|word|string|String|array|int|long|integer|double)\b/, builtin: /\b(?:KeyboardController|MouseController|SoftwareSerial|EthernetServer|EthernetClient|LiquidCrystal|LiquidCrystal_I2C|RobotControl|GSMVoiceCall|EthernetUDP|EsploraTFT|HttpClient|RobotMotor|WiFiClient|GSMScanner|FileSystem|Scheduler|GSMServer|YunClient|YunServer|IPAddress|GSMClient|GSMModem|Keyboard|Ethernet|Console|GSMBand|Esplora|Stepper|Process|WiFiUDP|GSM_SMS|Mailbox|USBHost|Firmata|PImage|Client|Server|GSMPIN|FileIO|Bridge|Serial|EEPROM|Stream|Mouse|Audio|Servo|File|Task|GPRS|WiFi|Wire|TFT|GSM|SPI|SD|runShellCommandAsynchronously|analogWriteResolution|retrieveCallingNumber|printFirmwareVersion|analogReadResolution|sendDigitalPortPair|noListenOnLocalhost|readJoystickButton|setFirmwareVersion|readJoystickSwitch|scrollDisplayRight|getVoiceCallStatus|scrollDisplayLeft|writeMicroseconds|delayMicroseconds|beginTransmission|getSignalStrength|runAsynchronously|getAsynchronously|listenOnLocalhost|getCurrentCarrier|readAccelerometer|messageAvailable|sendDigitalPorts|lineFollowConfig|countryNameWrite|runShellCommand|readStringUntil|rewindDirectory|readTemperature|setClockDivider|readLightSensor|endTransmission|analogReference|detachInterrupt|countryNameRead|attachInterrupt|encryptionType|readBytesUntil|robotNameWrite|readMicrophone|robotNameRead|cityNameWrite|userNameWrite|readJoystickY|readJoystickX|mouseReleased|openNextFile|scanNetworks|noInterrupts|digitalWrite|beginSpeaker|mousePressed|isActionDone|mouseDragged|displayLogos|noAutoscroll|addParameter|remoteNumber|getModifiers|keyboardRead|userNameRead|waitContinue|processInput|parseCommand|printVersion|readNetworks|writeMessage|blinkVersion|cityNameRead|readMessage|setDataMode|parsePacket|isListening|setBitOrder|beginPacket|isDirectory|motorsWrite|drawCompass|digitalRead|clearScreen|serialEvent|rightToLeft|setTextSize|leftToRight|requestFrom|keyReleased|compassRead|analogWrite|interrupts|WiFiServer|disconnect|playMelody|parseFloat|autoscroll|getPINUsed|setPINUsed|setTimeout|sendAnalog|readSlider|analogRead|beginWrite|createChar|motorsStop|keyPressed|tempoWrite|readButton|subnetMask|debugPrint|macAddress|writeGreen|randomSeed|attachGPRS|readString|sendString|remotePort|releaseAll|mouseMoved|background|getXChange|getYChange|answerCall|getResult|voiceCall|endPacket|constrain|getSocket|writeJSON|getButton|available|connected|findUntil|readBytes|exitValue|readGreen|writeBlue|startLoop|IPAddress|isPressed|sendSysex|pauseMode|gatewayIP|setCursor|getOemKey|tuneWrite|noDisplay|loadImage|switchPIN|onRequest|onReceive|changePIN|playFile|noBuffer|parseInt|overflow|checkPIN|knobRead|beginTFT|bitClear|updateIR|bitWrite|position|writeRGB|highByte|writeRed|setSpeed|readBlue|noStroke|remoteIP|transfer|shutdown|hangCall|beginSMS|endWrite|attached|maintain|noCursor|checkReg|checkPUK|shiftOut|isValid|shiftIn|pulseIn|connect|println|localIP|pinMode|getIMEI|display|noBlink|process|getBand|running|beginSD|drawBMP|lowByte|setBand|release|bitRead|prepare|pointTo|readRed|setMode|noFill|remove|listen|stroke|detach|attach|noTone|exists|buffer|height|bitSet|circle|config|cursor|random|IRread|setDNS|endSMS|getKey|micros|millis|begin|print|write|ready|flush|width|isPIN|blink|clear|press|mkdir|rmdir|close|point|yield|image|BSSID|click|delay|read|text|move|peek|beep|rect|line|open|seek|fill|size|turn|stop|home|find|step|tone|sqrt|RSSI|SSID|end|bit|tan|cos|sin|pow|map|abs|max|min|get|run|put)\b/, constant: /\b(?:DIGITAL_MESSAGE|FIRMATA_STRING|ANALOG_MESSAGE|REPORT_DIGITAL|REPORT_ANALOG|INPUT_PULLUP|SET_PIN_MODE|INTERNAL2V56|SYSTEM_RESET|LED_BUILTIN|INTERNAL1V1|SYSEX_START|INTERNAL|EXTERNAL|DEFAULT|OUTPUT|INPUT|HIGH|LOW)\b/ });
Prism.languages.docker = { keyword: { pattern: /(^\s*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)/im, lookbehind: !0 }, string: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/, comment: /#.*/, punctuation: /---|\.\.\.|[:[\]{}\-,|>?]/ }, Prism.languages.dockerfile = Prism.languages.docker;
Prism.languages["markup-templating"] = {}, Object.defineProperties(Prism.languages["markup-templating"], { buildPlaceholders: { value: function (e, t, n, a) { e.language === t && (e.tokenStack = [], e.code = e.code.replace(n, function (n) { if ("function" == typeof a && !a(n)) return n; for (var r = e.tokenStack.length; -1 !== e.code.indexOf("___" + t.toUpperCase() + r + "___");)++r; return e.tokenStack[r] = n, "___" + t.toUpperCase() + r + "___" }), e.grammar = Prism.languages.markup) } }, tokenizePlaceholders: { value: function (e, t) { if (e.language === t && e.tokenStack) { e.grammar = Prism.languages[t]; var n = 0, a = Object.keys(e.tokenStack), r = function (o) { if (!(n >= a.length)) for (var i = 0; i < o.length; i++) { var g = o[i]; if ("string" == typeof g || g.content && "string" == typeof g.content) { var c = a[n], s = e.tokenStack[c], l = "string" == typeof g ? g : g.content, p = l.indexOf("___" + t.toUpperCase() + c + "___"); if (p > -1) { ++n; var f, u = l.substring(0, p), _ = new Prism.Token(t, Prism.tokenize(s, e.grammar, t), "language-" + t, s), k = l.substring(p + ("___" + t.toUpperCase() + c + "___").length); if (u || k ? (f = [u, _, k].filter(function (e) { return !!e }), r(f)) : f = _, "string" == typeof g ? Array.prototype.splice.apply(o, [i, 1].concat(f)) : g.content = f, n >= a.length) break } } else g.content && "string" != typeof g.content && r(g.content) } }; r(e.tokens) } } } });
Prism.languages.git = { comment: /^#.*/m, deleted: /^[-–].*/m, inserted: /^\+.*/m, string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m, command: { pattern: /^.*\$ git .*$/m, inside: { parameter: /\s--?\w+/m } }, coord: /^@@.*@@$/m, commit_sha1: /^commit \w{40}$/m };
Prism.languages.json = { comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, property: { pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, greedy: !0 }, string: { pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, greedy: !0 }, number: /-?\d+\.?\d*(e[+-]?\d+)?/i, punctuation: /[{}[\],]/, operator: /:/, "boolean": /\b(?:true|false)\b/, "null": /\bnull\b/ }, Prism.languages.jsonp = Prism.languages.json;
Prism.languages.markdown = Prism.languages.extend("markup", {}), Prism.languages.insertBefore("markdown", "prolog", { blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, code: [{ pattern: /^(?: {4}|\t).+/m, alias: "keyword" }, { pattern: /``.+?``|`[^`\n]+`/, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: !0, inside: { "code-block": { pattern: /^(```.*(?:\r?\n|\r))[\s\S]+?(?=(?:\r?\n|\r)^```$)/m, lookbehind: !0 }, "code-language": { pattern: /^(```).+/, lookbehind: !0 }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\r?\n|\r)(?:==+|--+)/, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#+.+/m, lookbehind: !0, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: /(^|[^\\])(\*\*|__)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/, lookbehind: !0, greedy: !0, inside: { punctuation: /^\*\*|^__|\*\*$|__$/ } }, italic: { pattern: /(^|[^\\])([*_])(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/, lookbehind: !0, greedy: !0, inside: { punctuation: /^[*_]|[*_]$/ } }, strike: { pattern: /(^|[^\\])(~~?)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/, lookbehind: !0, greedy: !0, inside: { punctuation: /^~~?|~~?$/ } }, url: { pattern: /!?\[[^\]]+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)| ?\[[^\]\n]*\])/, inside: { variable: { pattern: /(!?\[)[^\]]+(?=\]$)/, lookbehind: !0 }, string: { pattern: /"(?:\\.|[^"\\])*"(?=\)$)/ } } } }), Prism.languages.markdown.bold.inside.url = Prism.languages.markdown.url, Prism.languages.markdown.italic.inside.url = Prism.languages.markdown.url, Prism.languages.markdown.strike.inside.url = Prism.languages.markdown.url, Prism.languages.markdown.bold.inside.italic = Prism.languages.markdown.italic, Prism.languages.markdown.bold.inside.strike = Prism.languages.markdown.strike, Prism.languages.markdown.italic.inside.bold = Prism.languages.markdown.bold, Prism.languages.markdown.italic.inside.strike = Prism.languages.markdown.strike, Prism.languages.markdown.strike.inside.bold = Prism.languages.markdown.bold, Prism.languages.markdown.strike.inside.italic = Prism.languages.markdown.italic, Prism.hooks.add("after-tokenize", function (a) { function n(a) { if (a && "string" != typeof a) for (var e = 0, i = a.length; i > e; e++) { var r = a[e]; if ("code" === r.type) { var t = r.content[1], s = r.content[3]; if (t && s && "code-language" === t.type && "code-block" === s.type && "string" == typeof t.content) { var o = "language-" + t.content.trim().split(/\s+/)[0].toLowerCase(); s.alias ? "string" == typeof s.alias ? s.alias = [s.alias, o] : s.alias.push(o) : s.alias = [o] } } else n(r.content) } } "markdown" === a.language && n(a.tokens) }), Prism.hooks.add("wrap", function (a) { if ("code-block" === a.type) { for (var n = "", e = 0, i = a.classes.length; i > e; e++) { var r = a.classes[e], t = /language-(\w+)/.exec(r); if (t) { n = t[1]; break } } var s = Prism.languages[n]; if (s) { var o = a.content.replace(/&lt;/g, "<").replace(/&amp;/g, "&"); a.content = Prism.highlight(o, s, n) } } }), Prism.languages.md = Prism.languages.markdown;
Prism.languages.nginx = Prism.languages.extend("clike", { comment: { pattern: /(^|[^"{\\])#.*/, lookbehind: !0 }, keyword: /\b(?:CONTENT_|DOCUMENT_|GATEWAY_|HTTP_|HTTPS|if_not_empty|PATH_|QUERY_|REDIRECT_|REMOTE_|REQUEST_|SCGI|SCRIPT_|SERVER_|http|events|accept_mutex|accept_mutex_delay|access_log|add_after_body|add_before_body|add_header|addition_types|aio|alias|allow|ancient_browser|ancient_browser_value|auth|auth_basic|auth_basic_user_file|auth_http|auth_http_header|auth_http_timeout|autoindex|autoindex_exact_size|autoindex_localtime|break|charset|charset_map|charset_types|chunked_transfer_encoding|client_body_buffer_size|client_body_in_file_only|client_body_in_single_buffer|client_body_temp_path|client_body_timeout|client_header_buffer_size|client_header_timeout|client_max_body_size|connection_pool_size|create_full_put_path|daemon|dav_access|dav_methods|debug_connection|debug_points|default_type|deny|devpoll_changes|devpoll_events|directio|directio_alignment|disable_symlinks|empty_gif|env|epoll_events|error_log|error_page|expires|fastcgi_buffer_size|fastcgi_buffers|fastcgi_busy_buffers_size|fastcgi_cache|fastcgi_cache_bypass|fastcgi_cache_key|fastcgi_cache_lock|fastcgi_cache_lock_timeout|fastcgi_cache_methods|fastcgi_cache_min_uses|fastcgi_cache_path|fastcgi_cache_purge|fastcgi_cache_use_stale|fastcgi_cache_valid|fastcgi_connect_timeout|fastcgi_hide_header|fastcgi_ignore_client_abort|fastcgi_ignore_headers|fastcgi_index|fastcgi_intercept_errors|fastcgi_keep_conn|fastcgi_max_temp_file_size|fastcgi_next_upstream|fastcgi_no_cache|fastcgi_param|fastcgi_pass|fastcgi_pass_header|fastcgi_read_timeout|fastcgi_redirect_errors|fastcgi_send_timeout|fastcgi_split_path_info|fastcgi_store|fastcgi_store_access|fastcgi_temp_file_write_size|fastcgi_temp_path|flv|geo|geoip_city|geoip_country|google_perftools_profiles|gzip|gzip_buffers|gzip_comp_level|gzip_disable|gzip_http_version|gzip_min_length|gzip_proxied|gzip_static|gzip_types|gzip_vary|if|if_modified_since|ignore_invalid_headers|image_filter|image_filter_buffer|image_filter_jpeg_quality|image_filter_sharpen|image_filter_transparency|imap_capabilities|imap_client_buffer|include|index|internal|ip_hash|keepalive|keepalive_disable|keepalive_requests|keepalive_timeout|kqueue_changes|kqueue_events|large_client_header_buffers|limit_conn|limit_conn_log_level|limit_conn_zone|limit_except|limit_rate|limit_rate_after|limit_req|limit_req_log_level|limit_req_zone|limit_zone|lingering_close|lingering_time|lingering_timeout|listen|location|lock_file|log_format|log_format_combined|log_not_found|log_subrequest|map|map_hash_bucket_size|map_hash_max_size|master_process|max_ranges|memcached_buffer_size|memcached_connect_timeout|memcached_next_upstream|memcached_pass|memcached_read_timeout|memcached_send_timeout|merge_slashes|min_delete_depth|modern_browser|modern_browser_value|mp4|mp4_buffer_size|mp4_max_buffer_size|msie_padding|msie_refresh|multi_accept|open_file_cache|open_file_cache_errors|open_file_cache_min_uses|open_file_cache_valid|open_log_file_cache|optimize_server_names|override_charset|pcre_jit|perl|perl_modules|perl_require|perl_set|pid|pop3_auth|pop3_capabilities|port_in_redirect|post_action|postpone_output|protocol|proxy|proxy_buffer|proxy_buffer_size|proxy_buffering|proxy_buffers|proxy_busy_buffers_size|proxy_cache|proxy_cache_bypass|proxy_cache_key|proxy_cache_lock|proxy_cache_lock_timeout|proxy_cache_methods|proxy_cache_min_uses|proxy_cache_path|proxy_cache_use_stale|proxy_cache_valid|proxy_connect_timeout|proxy_cookie_domain|proxy_cookie_path|proxy_headers_hash_bucket_size|proxy_headers_hash_max_size|proxy_hide_header|proxy_http_version|proxy_ignore_client_abort|proxy_ignore_headers|proxy_intercept_errors|proxy_max_temp_file_size|proxy_method|proxy_next_upstream|proxy_no_cache|proxy_pass|proxy_pass_error_message|proxy_pass_header|proxy_pass_request_body|proxy_pass_request_headers|proxy_read_timeout|proxy_redirect|proxy_redirect_errors|proxy_send_lowat|proxy_send_timeout|proxy_set_body|proxy_set_header|proxy_ssl_session_reuse|proxy_store|proxy_store_access|proxy_temp_file_write_size|proxy_temp_path|proxy_timeout|proxy_upstream_fail_timeout|proxy_upstream_max_fails|random_index|read_ahead|real_ip_header|recursive_error_pages|request_pool_size|reset_timedout_connection|resolver|resolver_timeout|return|rewrite|root|rtsig_overflow_events|rtsig_overflow_test|rtsig_overflow_threshold|rtsig_signo|satisfy|satisfy_any|secure_link_secret|send_lowat|send_timeout|sendfile|sendfile_max_chunk|server|server_name|server_name_in_redirect|server_names_hash_bucket_size|server_names_hash_max_size|server_tokens|set|set_real_ip_from|smtp_auth|smtp_capabilities|so_keepalive|source_charset|split_clients|ssi|ssi_silent_errors|ssi_types|ssi_value_length|ssl|ssl_certificate|ssl_certificate_key|ssl_ciphers|ssl_client_certificate|ssl_crl|ssl_dhparam|ssl_engine|ssl_prefer_server_ciphers|ssl_protocols|ssl_session_cache|ssl_session_timeout|ssl_verify_client|ssl_verify_depth|starttls|stub_status|sub_filter|sub_filter_once|sub_filter_types|tcp_nodelay|tcp_nopush|timeout|timer_resolution|try_files|types|types_hash_bucket_size|types_hash_max_size|underscores_in_headers|uninitialized_variable_warn|upstream|use|user|userid|userid_domain|userid_expires|userid_name|userid_p3p|userid_path|userid_service|valid_referers|variables_hash_bucket_size|variables_hash_max_size|worker_connections|worker_cpu_affinity|worker_priority|worker_processes|worker_rlimit_core|worker_rlimit_nofile|worker_rlimit_sigpending|working_directory|xclient|xml_entities|xslt_entities|xslt_stylesheet|xslt_types|ssl_session_tickets|ssl_stapling|ssl_stapling_verify|ssl_ecdh_curve|ssl_trusted_certificate|more_set_headers|ssl_early_data)\b/i }), Prism.languages.insertBefore("nginx", "keyword", { variable: /\$[a-z_]+/i });
Prism.languages.perl = { comment: [{ pattern: /(^\s*)=\w+[\s\S]*?=cut.*/m, lookbehind: !0 }, { pattern: /(^|[^\\$])#.*/, lookbehind: !0 }], string: [{ pattern: /\b(?:q|qq|qx|qw)\s*([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/, greedy: !0 }, { pattern: /\b(?:q|qq|qx|qw)\s+([a-zA-Z0-9])(?:(?!\1)[^\\]|\\[\s\S])*\1/, greedy: !0 }, { pattern: /\b(?:q|qq|qx|qw)\s*\((?:[^()\\]|\\[\s\S])*\)/, greedy: !0 }, { pattern: /\b(?:q|qq|qx|qw)\s*\{(?:[^{}\\]|\\[\s\S])*\}/, greedy: !0 }, { pattern: /\b(?:q|qq|qx|qw)\s*\[(?:[^[\]\\]|\\[\s\S])*\]/, greedy: !0 }, { pattern: /\b(?:q|qq|qx|qw)\s*<(?:[^<>\\]|\\[\s\S])*>/, greedy: !0 }, { pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/, greedy: !0 }, { pattern: /'(?:[^'\\\r\n]|\\.)*'/, greedy: !0 }], regex: [{ pattern: /\b(?:m|qr)\s*([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1[msixpodualngc]*/, greedy: !0 }, { pattern: /\b(?:m|qr)\s+([a-zA-Z0-9])(?:(?!\1)[^\\]|\\[\s\S])*\1[msixpodualngc]*/, greedy: !0 }, { pattern: /\b(?:m|qr)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngc]*/, greedy: !0 }, { pattern: /\b(?:m|qr)\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngc]*/, greedy: !0 }, { pattern: /\b(?:m|qr)\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngc]*/, greedy: !0 }, { pattern: /\b(?:m|qr)\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngc]*/, greedy: !0 }, { pattern: /(^|[^-]\b)(?:s|tr|y)\s*([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2[msixpodualngcer]*/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^-]\b)(?:s|tr|y)\s+([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2[msixpodualngcer]*/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^-]\b)(?:s|tr|y)\s*\((?:[^()\\]|\\[\s\S])*\)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngcer]*/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^-]\b)(?:s|tr|y)\s*\{(?:[^{}\\]|\\[\s\S])*\}\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngcer]*/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^-]\b)(?:s|tr|y)\s*\[(?:[^[\]\\]|\\[\s\S])*\]\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngcer]*/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^-]\b)(?:s|tr|y)\s*<(?:[^<>\\]|\\[\s\S])*>\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngcer]*/, lookbehind: !0, greedy: !0 }, { pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\b))/, greedy: !0 }], variable: [/[&*$@%]\{\^[A-Z]+\}/, /[&*$@%]\^[A-Z_]/, /[&*$@%]#?(?=\{)/, /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+)+(?:::)*/i, /[&*$@%]\d+/, /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/], filehandle: { pattern: /<(?![<=])\S*>|\b_\b/, alias: "symbol" }, vstring: { pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/, alias: "string" }, "function": { pattern: /sub [a-z0-9_]+/i, inside: { keyword: /sub/ } }, keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|say|state|sub|switch|undef|unless|until|use|when|while)\b/, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/, operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:lt|gt|le|ge|eq|ne|cmp|not|and|or|xor)\b/, punctuation: /[{}[\];(),:]/ };
!function (e) { e.languages.php = e.languages.extend("clike", { keyword: /\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|new|null|or|parent|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i, constant: /\b[A-Z_][A-Z0-9_]*\b/, comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/, lookbehind: !0 } }), e.languages.insertBefore("php", "string", { "shell-comment": { pattern: /(^|[^\\])#.*/, lookbehind: !0, alias: "comment" } }), e.languages.insertBefore("php", "keyword", { delimiter: { pattern: /\?>|<\?(?:php|=)?/i, alias: "important" }, variable: /\$+(?:\w+\b|(?={))/i, "package": { pattern: /(\\|namespace\s+|use\s+)[\w\\]+/, lookbehind: !0, inside: { punctuation: /\\/ } } }), e.languages.insertBefore("php", "operator", { property: { pattern: /(->)[\w]+/, lookbehind: !0 } }); var n = { pattern: /{\$(?:{(?:{[^{}]+}|[^{}]+)}|[^{}])+}|(^|[^\\{])\$+(?:\w+(?:\[.+?]|->\w+)*)/, lookbehind: !0, inside: { rest: e.languages.php } }; e.languages.insertBefore("php", "string", { "nowdoc-string": { pattern: /<<<'([^']+)'(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;/, greedy: !0, alias: "string", inside: { delimiter: { pattern: /^<<<'[^']+'|[a-z_]\w*;$/i, alias: "symbol", inside: { punctuation: /^<<<'?|[';]$/ } } } }, "heredoc-string": { pattern: /<<<(?:"([^"]+)"(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;|([a-z_]\w*)(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\2;)/i, greedy: !0, alias: "string", inside: { delimiter: { pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i, alias: "symbol", inside: { punctuation: /^<<<"?|[";]$/ } }, interpolation: n } }, "single-quoted-string": { pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: !0, alias: "string" }, "double-quoted-string": { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: !0, alias: "string", inside: { interpolation: n } } }), delete e.languages.php.string, e.hooks.add("before-tokenize", function (n) { if (/(?:<\?php|<\?)/gi.test(n.code)) { var t = /(?:<\?php|<\?)[\s\S]*?(?:\?>|$)/gi; e.languages["markup-templating"].buildPlaceholders(n, "php", t) } }), e.hooks.add("after-tokenize", function (n) { e.languages["markup-templating"].tokenizePlaceholders(n, "php") }) }(Prism);
Prism.languages.insertBefore("php", "variable", { "this": /\$this\b/, global: /\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)\b/, scope: { pattern: /\b[\w\\]+::/, inside: { keyword: /static|self|parent/, punctuation: /::|\\/ } } });
Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: !0 }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: !0, lookbehind: !0 }, "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, "boolean": /\b(?:TRUE|FALSE|NULL)\b/i, number: /\b0x[\da-f]+\b|\b\d+\.?\d*|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ };
Prism.languages.powershell = { comment: [{ pattern: /(^|[^`])<#[\s\S]*?#>/, lookbehind: !0 }, { pattern: /(^|[^`])#.*/, lookbehind: !0 }], string: [{ pattern: /"(?:`[\s\S]|[^`"])*"/, greedy: !0, inside: { "function": { pattern: /(^|[^`])\$\((?:\$\(.*?\)|(?!\$\()[^\r\n)])*\)/, lookbehind: !0, inside: {} } } }, { pattern: /'(?:[^']|'')*'/, greedy: !0 }], namespace: /\[[a-z](?:\[(?:\[[^\]]*]|[^\[\]])*]|[^\[\]])*]/i, "boolean": /\$(?:true|false)\b/i, variable: /\$\w+\b/i, "function": [/\b(?:Add-(?:Computer|Content|History|Member|PSSnapin|Type)|Checkpoint-Computer|Clear-(?:Content|EventLog|History|Item|ItemProperty|Variable)|Compare-Object|Complete-Transaction|Connect-PSSession|ConvertFrom-(?:Csv|Json|StringData)|Convert-Path|ConvertTo-(?:Csv|Html|Json|Xml)|Copy-(?:Item|ItemProperty)|Debug-Process|Disable-(?:ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Disconnect-PSSession|Enable-(?:ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Enter-PSSession|Exit-PSSession|Export-(?:Alias|Clixml|Console|Csv|FormatData|ModuleMember|PSSession)|ForEach-Object|Format-(?:Custom|List|Table|Wide)|Get-(?:Alias|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Culture|Date|Event|EventLog|EventSubscriber|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|WmiObject)|Group-Object|Import-(?:Alias|Clixml|Csv|LocalizedData|Module|PSSession)|Invoke-(?:Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)|Join-Path|Limit-EventLog|Measure-(?:Command|Object)|Move-(?:Item|ItemProperty)|New-(?:Alias|Event|EventLog|Item|ItemProperty|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy)|Out-(?:Default|File|GridView|Host|Null|Printer|String)|Pop-Location|Push-Location|Read-Host|Receive-(?:Job|PSSession)|Register-(?:EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)|Remove-(?:Computer|Event|EventLog|Item|ItemProperty|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)|Rename-(?:Computer|Item|ItemProperty)|Reset-ComputerMachinePassword|Resolve-Path|Restart-(?:Computer|Service)|Restore-Computer|Resume-(?:Job|Service)|Save-Help|Select-(?:Object|String|Xml)|Send-MailMessage|Set-(?:Alias|Content|Date|Item|ItemProperty|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)|Show-(?:Command|ControlPanelItem|EventLog)|Sort-Object|Split-Path|Start-(?:Job|Process|Service|Sleep|Transaction)|Stop-(?:Computer|Job|Process|Service)|Suspend-(?:Job|Service)|Tee-Object|Test-(?:ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)|Trace-Command|Unblock-File|Undo-Transaction|Unregister-(?:Event|PSSessionConfiguration)|Update-(?:FormatData|Help|List|TypeData)|Use-Transaction|Wait-(?:Event|Job|Process)|Where-Object|Write-(?:Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning))\b/i, /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i], keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i, operator: { pattern: /(\W?)(?:!|-(eq|ne|gt|ge|lt|le|sh[lr]|not|b?(?:and|x?or)|(?:Not)?(?:Like|Match|Contains|In)|Replace|Join|is(?:Not)?|as)\b|-[-=]?|\+[+=]?|[*\/%]=?)/i, lookbehind: !0 }, punctuation: /[|{}[\];(),.]/ }, Prism.languages.powershell.string[0].inside.boolean = Prism.languages.powershell.boolean, Prism.languages.powershell.string[0].inside.variable = Prism.languages.powershell.variable, Prism.languages.powershell.string[0].inside.function.inside = Prism.languages.powershell;
Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0 }, "string-interpolation": { pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: !0, inside: { interpolation: { pattern: /((?:^|[^{])(?:{{)*){(?!{)(?:[^{}]|{(?!{)(?:[^{}]|{(?!{)(?:[^{}])+})+})+}/, lookbehind: !0, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=}$)/, lookbehind: !0 }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]+?\1/i, greedy: !0, alias: "string" }, string: { pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: !0 }, "function": { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: !0 }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 }, decorator: { pattern: /(^\s*)@\w+(?:\.\w+)*/i, lookbehind: !0, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, "boolean": /\b(?:True|False|None)\b/, number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i, operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python;
!function (e) { var i = "(?:\\([^|)]+\\)|\\[[^\\]]+\\]|\\{[^}]+\\})+", n = { css: { pattern: /\{[^}]+\}/, inside: { rest: e.languages.css } }, "class-id": { pattern: /(\()[^)]+(?=\))/, lookbehind: !0, alias: "attr-value" }, lang: { pattern: /(\[)[^\]]+(?=\])/, lookbehind: !0, alias: "attr-value" }, punctuation: /[\\\/]\d+|\S/ }; e.languages.textile = e.languages.extend("markup", { phrase: { pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/, lookbehind: !0, inside: { "block-tag": { pattern: RegExp("^[a-z]\\w*(?:" + i + "|[<>=()])*\\."), inside: { modifier: { pattern: RegExp("(^[a-z]\\w*)(?:" + i + "|[<>=()])+(?=\\.)"), lookbehind: !0, inside: n }, tag: /^[a-z]\w*/, punctuation: /\.$/ } }, list: { pattern: RegExp("^[*#]+(?:" + i + ")?\\s+.+", "m"), inside: { modifier: { pattern: RegExp("(^[*#]+)" + i), lookbehind: !0, inside: n }, punctuation: /^[*#]+/ } }, table: { pattern: RegExp("^(?:(?:" + i + "|[<>=()^~])+\\.\\s*)?(?:\\|(?:(?:" + i + "|[<>=()^~_]|[\\\\/]\\d+)+\\.)?[^|]*)+\\|", "m"), inside: { modifier: { pattern: RegExp("(^|\\|(?:\\r?\\n|\\r)?)(?:" + i + "|[<>=()^~_]|[\\\\/]\\d+)+(?=\\.)"), lookbehind: !0, inside: n }, punctuation: /\||^\./ } }, inline: { pattern: RegExp("(\\*\\*|__|\\?\\?|[*_%@+\\-^~])(?:" + i + ")?.+?\\1"), inside: { bold: { pattern: RegExp("(^(\\*\\*?)(?:" + i + ")?).+?(?=\\2)"), lookbehind: !0 }, italic: { pattern: RegExp("(^(__?)(?:" + i + ")?).+?(?=\\2)"), lookbehind: !0 }, cite: { pattern: RegExp("(^\\?\\?(?:" + i + ")?).+?(?=\\?\\?)"), lookbehind: !0, alias: "string" }, code: { pattern: RegExp("(^@(?:" + i + ")?).+?(?=@)"), lookbehind: !0, alias: "keyword" }, inserted: { pattern: RegExp("(^\\+(?:" + i + ")?).+?(?=\\+)"), lookbehind: !0 }, deleted: { pattern: RegExp("(^-(?:" + i + ")?).+?(?=-)"), lookbehind: !0 }, span: { pattern: RegExp("(^%(?:" + i + ")?).+?(?=%)"), lookbehind: !0 }, modifier: { pattern: RegExp("(^\\*\\*|__|\\?\\?|[*_%@+\\-^~])" + i), lookbehind: !0, inside: n }, punctuation: /[*_%?@+\-^~]+/ } }, "link-ref": { pattern: /^\[[^\]]+\]\S+$/m, inside: { string: { pattern: /(\[)[^\]]+(?=\])/, lookbehind: !0 }, url: { pattern: /(\])\S+$/, lookbehind: !0 }, punctuation: /[\[\]]/ } }, link: { pattern: RegExp('"(?:' + i + ')?[^"]+":.+?(?=[^\\w/]?(?:\\s|$))'), inside: { text: { pattern: RegExp('(^"(?:' + i + ')?)[^"]+(?=")'), lookbehind: !0 }, modifier: { pattern: RegExp('(^")' + i), lookbehind: !0, inside: n }, url: { pattern: /(:).+/, lookbehind: !0 }, punctuation: /[":]/ } }, image: { pattern: RegExp("!(?:" + i + "|[<>=()])*[^!\\s()]+(?:\\([^)]+\\))?!(?::.+?(?=[^\\w/]?(?:\\s|$)))?"), inside: { source: { pattern: RegExp("(^!(?:" + i + "|[<>=()])*)[^!\\s()]+(?:\\([^)]+\\))?(?=!)"), lookbehind: !0, alias: "url" }, modifier: { pattern: RegExp("(^!)(?:" + i + "|[<>=()])+"), lookbehind: !0, inside: n }, url: { pattern: /(:).+/, lookbehind: !0 }, punctuation: /[!:]/ } }, footnote: { pattern: /\b\[\d+\]/, alias: "comment", inside: { punctuation: /\[|\]/ } }, acronym: { pattern: /\b[A-Z\d]+\([^)]+\)/, inside: { comment: { pattern: /(\()[^)]+(?=\))/, lookbehind: !0 }, punctuation: /[()]/ } }, mark: { pattern: /\b\((?:TM|R|C)\)/, alias: "comment", inside: { punctuation: /[()]/ } } } } }); var t = { inline: e.languages.textile.phrase.inside.inline, link: e.languages.textile.phrase.inside.link, image: e.languages.textile.phrase.inside.image, footnote: e.languages.textile.phrase.inside.footnote, acronym: e.languages.textile.phrase.inside.acronym, mark: e.languages.textile.phrase.inside.mark }; e.languages.textile.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i, e.languages.textile.phrase.inside.inline.inside.bold.inside = t, e.languages.textile.phrase.inside.inline.inside.italic.inside = t, e.languages.textile.phrase.inside.inline.inside.inserted.inside = t, e.languages.textile.phrase.inside.inline.inside.deleted.inside = t, e.languages.textile.phrase.inside.inline.inside.span.inside = t, e.languages.textile.phrase.inside.table.inside.inline = t.inline, e.languages.textile.phrase.inside.table.inside.link = t.link, e.languages.textile.phrase.inside.table.inside.image = t.image, e.languages.textile.phrase.inside.table.inside.footnote = t.footnote, e.languages.textile.phrase.inside.table.inside.acronym = t.acronym, e.languages.textile.phrase.inside.table.inside.mark = t.mark }(Prism);
!function () { function e(e, t) { return Array.prototype.slice.call((t || document).querySelectorAll(e)) } function t(e, t) { return t = " " + t + " ", (" " + e.className + " ").replace(/[\n\t]/g, " ").indexOf(t) > -1 } function n(e, n, i) { n = "string" == typeof n ? n : e.getAttribute("data-line"); for (var o, l = n.replace(/\s+/g, "").split(","), a = +e.getAttribute("data-line-offset") || 0, s = r() ? parseInt : parseFloat, d = s(getComputedStyle(e).lineHeight), u = t(e, "line-numbers"), c = 0; o = l[c++];) { var p = o.split("-"), m = +p[0], f = +p[1] || m, h = e.querySelector('.line-highlight[data-range="' + o + '"]') || document.createElement("div"); if (h.setAttribute("aria-hidden", "true"), h.setAttribute("data-range", o), h.className = (i || "") + " line-highlight", u && Prism.plugins.lineNumbers) { var g = Prism.plugins.lineNumbers.getLine(e, m), y = Prism.plugins.lineNumbers.getLine(e, f); g && (h.style.top = g.offsetTop + "px"), y && (h.style.height = y.offsetTop - g.offsetTop + y.offsetHeight + "px") } else h.setAttribute("data-start", m), f > m && h.setAttribute("data-end", f), h.style.top = (m - a - 1) * d + "px", h.textContent = new Array(f - m + 2).join(" \n"); u ? e.appendChild(h) : (e.querySelector("code") || e).appendChild(h) } } function i() { var t = location.hash.slice(1); e(".temporary.line-highlight").forEach(function (e) { e.parentNode.removeChild(e) }); var i = (t.match(/\.([\d,-]+)$/) || [, ""])[1]; if (i && !document.getElementById(t)) { var r = t.slice(0, t.lastIndexOf(".")), o = document.getElementById(r); o && (o.hasAttribute("data-line") || o.setAttribute("data-line", ""), n(o, i, "temporary "), document.querySelector(".temporary.line-highlight").scrollIntoView()) } } if ("undefined" != typeof self && self.Prism && self.document && document.querySelector) { var r = function () { var e; return function () { if ("undefined" == typeof e) { var t = document.createElement("div"); t.style.fontSize = "13px", t.style.lineHeight = "1.5", t.style.padding = 0, t.style.border = 0, t.innerHTML = "&nbsp;<br />&nbsp;", document.body.appendChild(t), e = 38 === t.offsetHeight, document.body.removeChild(t) } return e } }(), o = 0; Prism.hooks.add("before-sanity-check", function (t) { var n = t.element.parentNode, i = n && n.getAttribute("data-line"); if (n && i && /pre/i.test(n.nodeName)) { var r = 0; e(".line-highlight", n).forEach(function (e) { r += e.textContent.length, e.parentNode.removeChild(e) }), r && /^( \n)+$/.test(t.code.slice(-r)) && (t.code = t.code.slice(0, -r)) } }), Prism.hooks.add("complete", function l(e) { var r = e.element.parentNode, a = r && r.getAttribute("data-line"); if (r && a && /pre/i.test(r.nodeName)) { clearTimeout(o); var s = Prism.plugins.lineNumbers, d = e.plugins && e.plugins.lineNumbers; t(r, "line-numbers") && s && !d ? Prism.hooks.add("line-numbers", l) : (n(r, a), o = setTimeout(i, 1)) } }), window.addEventListener("hashchange", i), window.addEventListener("resize", function () { var e = document.querySelectorAll("pre[data-line]"); Array.prototype.forEach.call(e, function (e) { n(e) }) }) } }();
!function () { function t(t) { "function" != typeof t || e(t) || r.push(t) } function e(t) { return "function" == typeof t ? r.filter(function (e) { return e.valueOf() === t.valueOf() })[0] : "string" == typeof t && t.length > 0 ? r.filter(function (e) { return e.name === t })[0] : null } function n(t) { if ("string" == typeof t && (t = e(t)), "function" == typeof t) { var n = r.indexOf(t); n >= 0 && r.splice(n, 1) } } function a() { Array.prototype.slice.call(document.querySelectorAll("pre[data-jsonp]")).forEach(function (t) { t.textContent = ""; var e = document.createElement("code"); e.textContent = i, t.appendChild(e); var n = t.getAttribute("data-adapter"), a = null; if (n) { if ("function" != typeof window[n]) return e.textContent = "JSONP adapter function '" + n + "' doesn't exist", void 0; a = window[n] } var u = "prismjsonp" + o++, f = document.createElement("a"), l = f.href = t.getAttribute("data-jsonp"); f.href += (f.search ? "&" : "?") + (t.getAttribute("data-callback") || "callback") + "=" + u; var s = setTimeout(function () { e.textContent === i && (e.textContent = "Timeout loading '" + l + "'") }, 5e3), d = document.createElement("script"); d.src = f.href, window[u] = function (n) { document.head.removeChild(d), clearTimeout(s), delete window[u]; var o = ""; if (a) o = a(n, t); else for (var i in r) if (o = r[i](n, t), null !== o) break; null === o ? e.textContent = "Cannot parse response (perhaps you need an adapter function?)" : (e.textContent = o, Prism.highlightElement(e)) }, document.head.appendChild(d) }) } if (self.Prism && self.document && document.querySelectorAll && [].filter) { var r = []; Prism.plugins.jsonphighlight = { registerAdapter: t, removeAdapter: n, highlight: a }, t(function (t) { if (t && t.meta && t.data) { if (t.meta.status && t.meta.status >= 400) return "Error: " + (t.data.message || t.meta.status); if ("string" == typeof t.data.content) return "function" == typeof atob ? atob(t.data.content.replace(/\s/g, "")) : "Your browser cannot decode base64" } return null }), t(function (t, e) { if (t && t.meta && t.data && t.data.files) { if (t.meta.status && t.meta.status >= 400) return "Error: " + (t.data.message || t.meta.status); var n = e.getAttribute("data-filename"); if (null == n) for (var a in t.data.files) if (t.data.files.hasOwnProperty(a)) { n = a; break } return void 0 !== t.data.files[n] ? t.data.files[n].content : "Error: unknown or missing gist file " + n } return null }), t(function (t) { return t && t.node && "string" == typeof t.data ? t.data : null }); var o = 0, i = "Loading…"; a() } }();
!function () { "undefined" != typeof self && !self.Prism || "undefined" != typeof global && !global.Prism || Prism.hooks.add("wrap", function (e) { "keyword" === e.type && e.classes.push("keyword-" + e.content) }) }();
!function () { if (("undefined" == typeof self || self.Prism) && self.document && Function.prototype.bind) { var e = { gradient: { create: function () { var e = {}, s = function (e, s, i) { var t = "180deg"; return /^(?:-?\d*\.?\d+(?:deg|rad)|to\b|top|right|bottom|left)/.test(i[0]) && (t = i.shift(), t.indexOf("to ") < 0 && (t.indexOf("top") >= 0 ? t = t.indexOf("left") >= 0 ? "to bottom right" : t.indexOf("right") >= 0 ? "to bottom left" : "to bottom" : t.indexOf("bottom") >= 0 ? t = t.indexOf("left") >= 0 ? "to top right" : t.indexOf("right") >= 0 ? "to top left" : "to top" : t.indexOf("left") >= 0 ? t = "to right" : t.indexOf("right") >= 0 ? t = "to left" : e && (t.indexOf("deg") >= 0 ? t = 90 - parseFloat(t) + "deg" : t.indexOf("rad") >= 0 && (t = Math.PI / 2 - parseFloat(t) + "rad")))), s + "(" + t + "," + i.join(",") + ")" }, i = function (e, s, i) { if (i[0].indexOf("at") < 0) { var t = "center", a = "ellipse", r = "farthest-corner"; if (/\bcenter|top|right|bottom|left\b|^\d+/.test(i[0]) && (t = i.shift().replace(/\s*-?\d+(?:rad|deg)\s*/, "")), /\bcircle|ellipse|closest|farthest|contain|cover\b/.test(i[0])) { var n = i.shift().split(/\s+/); !n[0] || "circle" !== n[0] && "ellipse" !== n[0] || (a = n.shift()), n[0] && (r = n.shift()), "cover" === r ? r = "farthest-corner" : "contain" === r && (r = "clothest-side") } return s + "(" + a + " " + r + " at " + t + "," + i.join(",") + ")" } return s + "(" + i.join(",") + ")" }, t = function (t) { if (e[t]) return e[t]; var a = t.match(/^(\b|\B-[a-z]{1,10}-)((?:repeating-)?(?:linear|radial)-gradient)/), r = a && a[1], n = a && a[2], l = t.replace(/^(?:\b|\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\(|\)$/g, "").split(/\s*,\s*/); return e[t] = n.indexOf("linear") >= 0 ? s(r, n, l) : n.indexOf("radial") >= 0 ? i(r, n, l) : n + "(" + l.join(",") + ")" }; return function () { new Prism.plugins.Previewer("gradient", function (e) { return this.firstChild.style.backgroundImage = "", this.firstChild.style.backgroundImage = t(e), !!this.firstChild.style.backgroundImage }, "*", function () { this._elt.innerHTML = "<div></div>" }) } }(), tokens: { gradient: { pattern: /(?:\b|\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\((?:(?:rgb|hsl)a?\(.+?\)|[^\)])+\)/gi, inside: { "function": /[\w-]+(?=\()/, punctuation: /[(),]/ } } }, languages: { css: !0, less: !0, sass: [{ lang: "sass", before: "punctuation", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["variable-line"] }, { lang: "sass", before: "punctuation", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["property-line"] }], scss: !0, stylus: [{ lang: "stylus", before: "func", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["property-declaration"].inside }, { lang: "stylus", before: "func", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["variable-declaration"].inside }] } }, angle: { create: function () { new Prism.plugins.Previewer("angle", function (e) { var s, i, t = parseFloat(e), a = e.match(/[a-z]+$/i); if (!t || !a) return !1; switch (a = a[0]) { case "deg": s = 360; break; case "grad": s = 400; break; case "rad": s = 2 * Math.PI; break; case "turn": s = 1 }return i = 100 * t / s, i %= 100, this[(0 > t ? "set" : "remove") + "Attribute"]("data-negative", ""), this.querySelector("circle").style.strokeDasharray = Math.abs(i) + ",500", !0 }, "*", function () { this._elt.innerHTML = '<svg viewBox="0 0 64 64"><circle r="16" cy="32" cx="32"></circle></svg>' }) }, tokens: { angle: /(?:\b|\B-|(?=\B\.))\d*\.?\d+(?:deg|g?rad|turn)\b/i }, languages: { css: !0, less: !0, markup: { lang: "markup", before: "punctuation", inside: "inside", root: Prism.languages.markup && Prism.languages.markup.tag.inside["attr-value"] }, sass: [{ lang: "sass", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["property-line"] }, { lang: "sass", before: "operator", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["variable-line"] }], scss: !0, stylus: [{ lang: "stylus", before: "func", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["property-declaration"].inside }, { lang: "stylus", before: "func", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["variable-declaration"].inside }] } }, color: { create: function () { new Prism.plugins.Previewer("color", function (e) { return this.style.backgroundColor = "", this.style.backgroundColor = e, !!this.style.backgroundColor }) }, tokens: { color: { pattern: /\B#(?:[0-9a-f]{3}){1,2}\b|\b(?:rgb|hsl)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:rgb|hsl)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B|\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGray|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGray|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGray|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gray|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGray|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGray|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGray|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, inside: { "function": /[\w-]+(?=\()/, punctuation: /[(),]/ } } }, languages: { css: !0, less: !0, markup: { lang: "markup", before: "punctuation", inside: "inside", root: Prism.languages.markup && Prism.languages.markup.tag.inside["attr-value"] }, sass: [{ lang: "sass", before: "punctuation", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["variable-line"] }, { lang: "sass", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["property-line"] }], scss: !0, stylus: [{ lang: "stylus", before: "hexcode", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["property-declaration"].inside }, { lang: "stylus", before: "hexcode", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["variable-declaration"].inside }] } }, easing: { create: function () { new Prism.plugins.Previewer("easing", function (e) { e = { linear: "0,0,1,1", ease: ".25,.1,.25,1", "ease-in": ".42,0,1,1", "ease-out": "0,0,.58,1", "ease-in-out": ".42,0,.58,1" }[e] || e; var s = e.match(/-?\d*\.?\d+/g); if (4 === s.length) { s = s.map(function (e, s) { return 100 * (s % 2 ? 1 - e : e) }), this.querySelector("path").setAttribute("d", "M0,100 C" + s[0] + "," + s[1] + ", " + s[2] + "," + s[3] + ", 100,0"); var i = this.querySelectorAll("line"); return i[0].setAttribute("x2", s[0]), i[0].setAttribute("y2", s[1]), i[1].setAttribute("x2", s[2]), i[1].setAttribute("y2", s[3]), !0 } return !1 }, "*", function () { this._elt.innerHTML = '<svg viewBox="-20 -20 140 140" width="100" height="100"><defs><marker id="prism-previewer-easing-marker" viewBox="0 0 4 4" refX="2" refY="2" markerUnits="strokeWidth"><circle cx="2" cy="2" r="1.5" /></marker></defs><path d="M0,100 C20,50, 40,30, 100,0" /><line x1="0" y1="100" x2="20" y2="50" marker-start="url(' + location.href + '#prism-previewer-easing-marker)" marker-end="url(' + location.href + '#prism-previewer-easing-marker)" /><line x1="100" y1="0" x2="40" y2="30" marker-start="url(' + location.href + '#prism-previewer-easing-marker)" marker-end="url(' + location.href + '#prism-previewer-easing-marker)" /></svg>' }) }, tokens: { easing: { pattern: /\bcubic-bezier\((?:-?\d*\.?\d+,\s*){3}-?\d*\.?\d+\)\B|\b(?:linear|ease(?:-in)?(?:-out)?)(?=\s|[;}]|$)/i, inside: { "function": /[\w-]+(?=\()/, punctuation: /[(),]/ } } }, languages: { css: !0, less: !0, sass: [{ lang: "sass", inside: "inside", before: "punctuation", root: Prism.languages.sass && Prism.languages.sass["variable-line"] }, { lang: "sass", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["property-line"] }], scss: !0, stylus: [{ lang: "stylus", before: "hexcode", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["property-declaration"].inside }, { lang: "stylus", before: "hexcode", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["variable-declaration"].inside }] } }, time: { create: function () { new Prism.plugins.Previewer("time", function (e) { var s = parseFloat(e), i = e.match(/[a-z]+$/i); return s && i ? (i = i[0], this.querySelector("circle").style.animationDuration = 2 * s + i, !0) : !1 }, "*", function () { this._elt.innerHTML = '<svg viewBox="0 0 64 64"><circle r="16" cy="32" cx="32"></circle></svg>' }) }, tokens: { time: /(?:\b|\B-|(?=\B\.))\d*\.?\d+m?s\b/i }, languages: { css: !0, less: !0, markup: { lang: "markup", before: "punctuation", inside: "inside", root: Prism.languages.markup && Prism.languages.markup.tag.inside["attr-value"] }, sass: [{ lang: "sass", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["property-line"] }, { lang: "sass", before: "operator", inside: "inside", root: Prism.languages.sass && Prism.languages.sass["variable-line"] }], scss: !0, stylus: [{ lang: "stylus", before: "hexcode", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["property-declaration"].inside }, { lang: "stylus", before: "hexcode", inside: "rest", root: Prism.languages.stylus && Prism.languages.stylus["variable-declaration"].inside }] } } }, s = function (e) { var s = e.getBoundingClientRect(), i = s.left, t = s.top, a = document.documentElement.getBoundingClientRect(); return i -= a.left, t -= a.top, { top: t, right: innerWidth - i - s.width, bottom: innerHeight - t - s.height, left: i, width: s.width, height: s.height } }, i = /(?:^|\s)token(?=$|\s)/, t = /(?:^|\s)active(?=$|\s)/g, a = /(?:^|\s)flipped(?=$|\s)/g, r = function (e, s, i, t) { this._elt = null, this._type = e, this._clsRegexp = RegExp("(?:^|\\s)" + e + "(?=$|\\s)"), this._token = null, this.updater = s, this._mouseout = this.mouseout.bind(this), this.initializer = t; var a = this; i || (i = ["*"]), "Array" !== Prism.util.type(i) && (i = [i]), i.forEach(function (e) { "string" != typeof e && (e = e.lang), r.byLanguages[e] || (r.byLanguages[e] = []), r.byLanguages[e].indexOf(a) < 0 && r.byLanguages[e].push(a) }), r.byType[e] = this }; r.prototype.init = function () { this._elt || (this._elt = document.createElement("div"), this._elt.className = "prism-previewer prism-previewer-" + this._type, document.body.appendChild(this._elt), this.initializer && this.initializer()) }, r.prototype.isDisabled = function (e) { do if (e.hasAttribute && e.hasAttribute("data-previewers")) { var s = e.getAttribute("data-previewers"); return -1 === (s || "").split(/\s+/).indexOf(this._type) } while (e = e.parentNode); return !1 }, r.prototype.check = function (e) { if (!i.test(e.className) || !this.isDisabled(e)) { do if (i.test(e.className) && this._clsRegexp.test(e.className)) break; while (e = e.parentNode); e && e !== this._token && (this._token = e, this.show()) } }, r.prototype.mouseout = function () { this._token.removeEventListener("mouseout", this._mouseout, !1), this._token = null, this.hide() }, r.prototype.show = function () { if (this._elt || this.init(), this._token) if (this.updater.call(this._elt, this._token.textContent)) { this._token.addEventListener("mouseout", this._mouseout, !1); var e = s(this._token); this._elt.className += " active", e.top - this._elt.offsetHeight > 0 ? (this._elt.className = this._elt.className.replace(a, ""), this._elt.style.top = e.top + "px", this._elt.style.bottom = "") : (this._elt.className += " flipped", this._elt.style.bottom = e.bottom + "px", this._elt.style.top = ""), this._elt.style.left = e.left + Math.min(200, e.width / 2) + "px" } else this.hide() }, r.prototype.hide = function () { this._elt.className = this._elt.className.replace(t, "") }, r.byLanguages = {}, r.byType = {}, r.initEvents = function (e, s) { var i = []; r.byLanguages[s] && (i = i.concat(r.byLanguages[s])), r.byLanguages["*"] && (i = i.concat(r.byLanguages["*"])), e.addEventListener("mouseover", function (e) { var s = e.target; i.forEach(function (e) { e.check(s) }) }, !1) }, Prism.plugins.Previewer = r, Prism.hooks.add("before-highlight", function (s) { for (var i in e) { var t = e[i].languages; if (s.language && t[s.language] && !t[s.language].initialized) { var a = t[s.language]; "Array" !== Prism.util.type(a) && (a = [a]), a.forEach(function (a) { var r, n, l, o; a === !0 ? (r = "important", n = s.language, a = s.language) : (r = a.before || "important", n = a.inside || a.lang, l = a.root || Prism.languages, o = a.skip, a = s.language), !o && Prism.languages[a] && (Prism.languages.insertBefore(n, r, e[i].tokens, l), s.grammar = Prism.languages[a], t[s.language] = { initialized: !0 }) }) } } }), Prism.hooks.add("after-highlight", function (e) { (r.byLanguages["*"] || r.byLanguages[e.language]) && r.initEvents(e.element, e.language) }); for (var n in e) e[n].create() } }();
!function () { if ("undefined" != typeof self && self.Prism && self.document) { var e = /(?:^|\s)command-line(?:\s|$)/; Prism.hooks.add("before-highlight", function (t) { var a = t.vars = t.vars || {}, n = a["command-line"] = a["command-line"] || {}; if (n.complete || !t.code) return n.complete = !0, void 0; var r = t.element.parentNode; if (!r || !/pre/i.test(r.nodeName) || !e.test(r.className) && !e.test(t.element.className)) return n.complete = !0, void 0; if (t.element.querySelector(".command-line-prompt")) return n.complete = !0, void 0; var o = t.code.split("\n"); n.numberOfLines = o.length; var s = n.outputLines = [], i = r.getAttribute("data-output"), l = r.getAttribute("data-filter-output"); if (i || "" === i) { i = i.split(","); for (var m = 0; m < i.length; m++) { var d = i[m].split("-"), p = parseInt(d[0], 10), c = 2 === d.length ? parseInt(d[1], 10) : p; if (!isNaN(p) && !isNaN(c)) { 1 > p && (p = 1), c > o.length && (c = o.length), p-- , c--; for (var u = p; c >= u; u++)s[u] = o[u], o[u] = "" } } } else if (l) for (var m = 0; m < o.length; m++)0 === o[m].indexOf(l) && (s[m] = o[m].slice(l.length), o[m] = ""); t.code = o.join("\n") }), Prism.hooks.add("before-insert", function (e) { var t = e.vars = e.vars || {}, a = t["command-line"] = t["command-line"] || {}; if (!a.complete) { for (var n = e.highlightedCode.split("\n"), r = 0; r < a.outputLines.length; r++)a.outputLines.hasOwnProperty(r) && (n[r] = a.outputLines[r]); e.highlightedCode = n.join("\n") } }), Prism.hooks.add("complete", function (t) { var a = t.vars = t.vars || {}, n = a["command-line"] = a["command-line"] || {}; if (!n.complete) { var r = t.element.parentNode; e.test(t.element.className) && (t.element.className = t.element.className.replace(e, " ")), e.test(r.className) || (r.className += " command-line"); var o = function (e, t) { return (r.getAttribute(e) || t).replace(/"/g, "&quot") }, s = new Array(n.numberOfLines + 1), i = o("data-prompt", ""); if ("" !== i) s = s.join('<span data-prompt="' + i + '"></span>'); else { var l = o("data-user", "user"), m = o("data-host", "localhost"); s = s.join('<span data-user="' + l + '" data-host="' + m + '"></span>') } var d = document.createElement("span"); d.className = "command-line-prompt", d.innerHTML = s; for (var p = 0; p < n.outputLines.length; p++)if (n.outputLines.hasOwnProperty(p)) { var c = d.children[p]; c.removeAttribute("data-user"), c.removeAttribute("data-host"), c.removeAttribute("data-prompt") } t.element.insertBefore(d, t.element.firstChild), n.complete = !0 } }) } }();
!function () { function e(e) { this.defaults = r({}, e) } function n(e) { return e.replace(/-(\w)/g, function (e, n) { return n.toUpperCase() }) } function t(e) { for (var n = 0, t = 0; t < e.length; ++t)e.charCodeAt(t) == "	".charCodeAt(0) && (n += 3); return e.length + n } var r = Object.assign || function (e, n) { for (var t in n) n.hasOwnProperty(t) && (e[t] = n[t]); return e }; e.prototype = { setDefaults: function (e) { this.defaults = r(this.defaults, e) }, normalize: function (e, t) { t = r(this.defaults, t); for (var i in t) { var o = n(i); "normalize" !== i && "setDefaults" !== o && t[i] && this[o] && (e = this[o].call(this, e, t[i])) } return e }, leftTrim: function (e) { return e.replace(/^\s+/, "") }, rightTrim: function (e) { return e.replace(/\s+$/, "") }, tabsToSpaces: function (e, n) { return n = 0 | n || 4, e.replace(/\t/g, new Array(++n).join(" ")) }, spacesToTabs: function (e, n) { return n = 0 | n || 4, e.replace(RegExp(" {" + n + "}", "g"), "	") }, removeTrailing: function (e) { return e.replace(/\s*?$/gm, "") }, removeInitialLineFeed: function (e) { return e.replace(/^(?:\r?\n|\r)/, "") }, removeIndent: function (e) { var n = e.match(/^[^\S\n\r]*(?=\S)/gm); return n && n[0].length ? (n.sort(function (e, n) { return e.length - n.length }), n[0].length ? e.replace(RegExp("^" + n[0], "gm"), "") : e) : e }, indent: function (e, n) { return e.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++n).join("	") + "$&") }, breakLines: function (e, n) { n = n === !0 ? 80 : 0 | n || 80; for (var r = e.split("\n"), i = 0; i < r.length; ++i)if (!(t(r[i]) <= n)) { for (var o = r[i].split(/(\s+)/g), a = 0, s = 0; s < o.length; ++s) { var l = t(o[s]); a += l, a > n && (o[s] = "\n" + o[s], a = l) } r[i] = o.join("") } return r.join("\n") } }, "undefined" != typeof module && module.exports && (module.exports = e), "undefined" != typeof Prism && (Prism.plugins.NormalizeWhitespace = new e({ "remove-trailing": !0, "remove-indent": !0, "left-trim": !0, "right-trim": !0 }), Prism.hooks.add("before-sanity-check", function (e) { var n = Prism.plugins.NormalizeWhitespace; if (!e.settings || e.settings["whitespace-normalization"] !== !1) { if ((!e.element || !e.element.parentNode) && e.code) return e.code = n.normalize(e.code, e.settings), void 0; var t = e.element.parentNode, r = /\bno-whitespace-normalization\b/; if (e.code && t && "pre" === t.nodeName.toLowerCase() && !r.test(t.className) && !r.test(e.element.className)) { for (var i = t.childNodes, o = "", a = "", s = !1, l = 0; l < i.length; ++l) { var c = i[l]; c == e.element ? s = !0 : "#text" === c.nodeName && (s ? a += c.nodeValue : o += c.nodeValue, t.removeChild(c), --l) } if (e.element.children.length && Prism.plugins.KeepMarkup) { var u = o + e.element.innerHTML + a; e.element.innerHTML = n.normalize(u, e.settings), e.code = e.element.textContent } else e.code = o + e.code + a, e.code = n.normalize(e.code, e.settings) } } })) }();